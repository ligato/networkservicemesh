// Code generated by protoc-gen-go. DO NOT EDIT.
// source: internsm.proto

package internsm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "github.com/ligato/networkservicemesh/pkg/nsm/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// RemoteConnectionState - state of the RemoteConnection
type RemoteConnectionState int32

const (
	// REQUESTED - State of RemoteConnection in RemoteConnectionRequest
	RemoteConnectionState_REQUESTED RemoteConnectionState = 0
	// CONNECTED - State of RemoteConnection in RemoteConnectionReply in response to RequestRemoteConnection
	RemoteConnectionState_CONNECTED RemoteConnectionState = 1
	// CLOSE_REQUESTED - State of RemoteConnection passed to RemoteConnectionReply in response to DeleteRemoeConnection
	RemoteConnectionState_CLOSE_REQUESTED RemoteConnectionState = 2
	// CLOSED - State of the RemoteConnection in RemoteConnectionReply in response to DeleteRemoteConnection
	RemoteConnectionState_CLOSED RemoteConnectionState = 3
)

var RemoteConnectionState_name = map[int32]string{
	0: "REQUESTED",
	1: "CONNECTED",
	2: "CLOSE_REQUESTED",
	3: "CLOSED",
}
var RemoteConnectionState_value = map[string]int32{
	"REQUESTED":       0,
	"CONNECTED":       1,
	"CLOSE_REQUESTED": 2,
	"CLOSED":          3,
}

func (x RemoteConnectionState) String() string {
	return proto.EnumName(RemoteConnectionState_name, int32(x))
}
func (RemoteConnectionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_internsm_3a67740ace59b57b, []int{0}
}

// RemoteConnectionId - uniquely identifies the connection
// Note: A connection in Requested state may have a partially specified RemoteConnectionId.  A RemoteConnectionId must be fully specified in CONNECTED state
type RemoteConnectionId struct {
	// source_nsm_id - Id of the source NSM - provided authoritatively by source NSM in RemoteConnectionRequest
	// Can be used for 'recovery' in the event of an NSM restart by 'Monitoring' all RemoteConnections
	// from its peers matching its own source_nsm_id
	SourceNsmId string `protobuf:"bytes,1,opt,name=source_nsm_id,json=sourceNsmId" json:"source_nsm_id,omitempty"`
	// destination_nsm_id - Id of the destination NSM - provided authoritatively by the destination NSM in RemoteConnectionReply
	DestinationNsmId string `protobuf:"bytes,2,opt,name=destination_nsm_id,json=destinationNsmId" json:"destination_nsm_id,omitempty"`
	// source_connection_id - Id of the source NSM's end of the connection - provided authoritatively by the source NSM in RemoteConnectionRequest
	SourceConnectionId string `protobuf:"bytes,3,opt,name=source_connection_id,json=sourceConnectionId" json:"source_connection_id,omitempty"`
	// destination_connection_id - Id of the destination NSM's end of the connection - provided authoritatively by the destination NSM in the RemoteConnectionReply
	DestinationConnectionId string   `protobuf:"bytes,4,opt,name=destination_connection_id,json=destinationConnectionId" json:"destination_connection_id,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *RemoteConnectionId) Reset()         { *m = RemoteConnectionId{} }
func (m *RemoteConnectionId) String() string { return proto.CompactTextString(m) }
func (*RemoteConnectionId) ProtoMessage()    {}
func (*RemoteConnectionId) Descriptor() ([]byte, []int) {
	return fileDescriptor_internsm_3a67740ace59b57b, []int{0}
}
func (m *RemoteConnectionId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoteConnectionId.Unmarshal(m, b)
}
func (m *RemoteConnectionId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoteConnectionId.Marshal(b, m, deterministic)
}
func (dst *RemoteConnectionId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteConnectionId.Merge(dst, src)
}
func (m *RemoteConnectionId) XXX_Size() int {
	return xxx_messageInfo_RemoteConnectionId.Size(m)
}
func (m *RemoteConnectionId) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteConnectionId.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteConnectionId proto.InternalMessageInfo

func (m *RemoteConnectionId) GetSourceNsmId() string {
	if m != nil {
		return m.SourceNsmId
	}
	return ""
}

func (m *RemoteConnectionId) GetDestinationNsmId() string {
	if m != nil {
		return m.DestinationNsmId
	}
	return ""
}

func (m *RemoteConnectionId) GetSourceConnectionId() string {
	if m != nil {
		return m.SourceConnectionId
	}
	return ""
}

func (m *RemoteConnectionId) GetDestinationConnectionId() string {
	if m != nil {
		return m.DestinationConnectionId
	}
	return ""
}

// RemoteConnection - represents a RemoteConnection, may be partially or fully specified
type RemoteConnection struct {
	//  id of the remote connection - must be unique when fully specified
	Id *RemoteConnectionId `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	//  state of the remote connection
	State RemoteConnectionState `protobuf:"varint,2,opt,name=state,enum=internsm.RemoteConnectionState" json:"state,omitempty"`
	//  network_service_name - Name of the Network Service at the destination of the RemoteConnection
	NetworkServiceName string `protobuf:"bytes,3,opt,name=network_service_name,json=networkServiceName" json:"network_service_name,omitempty"`
	//  network_service_endpoint_name - Name of the specific Network Service Endpoint at the destination of the RemoteConnection
	NetworkServiceEndpointName string `protobuf:"bytes,4,opt,name=network_service_endpoint_name,json=networkServiceEndpointName" json:"network_service_endpoint_name,omitempty"`
	//  remote_mechanism - RemoteMechanism for the remote connection.  Must be empty in RequestRemoteConnection.  Must by fully specified in RemoteConnectionReply
	RemoteMechanism *common.RemoteMechanism `protobuf:"bytes,5,opt,name=remote_mechanism,json=remoteMechanism" json:"remote_mechanism,omitempty"`
	// connection_context - conntection_context of the remote connection.
	ConnectionContext *common.ConnectionContext `protobuf:"bytes,6,opt,name=connection_context,json=connectionContext" json:"connection_context,omitempty"`
	// labels - meta data about the RemoteConnection.  Typically provided in RequestRemoteConnection and not changed from there.
	Labels               map[string]string `protobuf:"bytes,7,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RemoteConnection) Reset()         { *m = RemoteConnection{} }
func (m *RemoteConnection) String() string { return proto.CompactTextString(m) }
func (*RemoteConnection) ProtoMessage()    {}
func (*RemoteConnection) Descriptor() ([]byte, []int) {
	return fileDescriptor_internsm_3a67740ace59b57b, []int{1}
}
func (m *RemoteConnection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoteConnection.Unmarshal(m, b)
}
func (m *RemoteConnection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoteConnection.Marshal(b, m, deterministic)
}
func (dst *RemoteConnection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteConnection.Merge(dst, src)
}
func (m *RemoteConnection) XXX_Size() int {
	return xxx_messageInfo_RemoteConnection.Size(m)
}
func (m *RemoteConnection) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteConnection.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteConnection proto.InternalMessageInfo

func (m *RemoteConnection) GetId() *RemoteConnectionId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RemoteConnection) GetState() RemoteConnectionState {
	if m != nil {
		return m.State
	}
	return RemoteConnectionState_REQUESTED
}

func (m *RemoteConnection) GetNetworkServiceName() string {
	if m != nil {
		return m.NetworkServiceName
	}
	return ""
}

func (m *RemoteConnection) GetNetworkServiceEndpointName() string {
	if m != nil {
		return m.NetworkServiceEndpointName
	}
	return ""
}

func (m *RemoteConnection) GetRemoteMechanism() *common.RemoteMechanism {
	if m != nil {
		return m.RemoteMechanism
	}
	return nil
}

func (m *RemoteConnection) GetConnectionContext() *common.ConnectionContext {
	if m != nil {
		return m.ConnectionContext
	}
	return nil
}

func (m *RemoteConnection) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// RemoteConnectionRequest - Request for a RemoteConnection
type RemoteConnectionRequest struct {
	// remote_connection - partially specified RemoteConnection being requested
	RemoteConnection *RemoteConnection `protobuf:"bytes,1,opt,name=remote_connection,json=remoteConnection" json:"remote_connection,omitempty"`
	// supported_remote_mechanisms - preference ordered list of supported_remote_mechanisms for the source NSM
	// The destination NSM should try to pick the highest prference remote_mechanism to fully specify and use to complete the connection.
	SupportedRemoteMechanisms []*common.RemoteMechanism `protobuf:"bytes,4,rep,name=supported_remote_mechanisms,json=supportedRemoteMechanisms" json:"supported_remote_mechanisms,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}                  `json:"-"`
	XXX_unrecognized          []byte                    `json:"-"`
	XXX_sizecache             int32                     `json:"-"`
}

func (m *RemoteConnectionRequest) Reset()         { *m = RemoteConnectionRequest{} }
func (m *RemoteConnectionRequest) String() string { return proto.CompactTextString(m) }
func (*RemoteConnectionRequest) ProtoMessage()    {}
func (*RemoteConnectionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_internsm_3a67740ace59b57b, []int{2}
}
func (m *RemoteConnectionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoteConnectionRequest.Unmarshal(m, b)
}
func (m *RemoteConnectionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoteConnectionRequest.Marshal(b, m, deterministic)
}
func (dst *RemoteConnectionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteConnectionRequest.Merge(dst, src)
}
func (m *RemoteConnectionRequest) XXX_Size() int {
	return xxx_messageInfo_RemoteConnectionRequest.Size(m)
}
func (m *RemoteConnectionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteConnectionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteConnectionRequest proto.InternalMessageInfo

func (m *RemoteConnectionRequest) GetRemoteConnection() *RemoteConnection {
	if m != nil {
		return m.RemoteConnection
	}
	return nil
}

func (m *RemoteConnectionRequest) GetSupportedRemoteMechanisms() []*common.RemoteMechanism {
	if m != nil {
		return m.SupportedRemoteMechanisms
	}
	return nil
}

// RemoteConnectionReply - Reply to a RemoteConnectionRequest
type RemoteConnectionReply struct {
	// success - true of operation was successful - false otherwise
	// In RequestRemoteConnection this means the destination NSMs end of the RemoteConnection is fully operational
	// In UpdateRemoteConnection this means the destination NSM has been able to negotiate successfully the
	//    update to the ConnectionContext with the NSE
	// In DeleteRemoteConnection this means the connection is now fully deleted in the Destination NSM
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	// extended_error - String explaining error condition of success == false.  Must be empty if success = true.
	ExtendedError string `protobuf:"bytes,2,opt,name=extended_error,json=extendedError" json:"extended_error,omitempty"`
	//  remote_connection - fully specified RemoteConnection
	RemoteConnection     *RemoteConnection `protobuf:"bytes,3,opt,name=remote_connection,json=remoteConnection" json:"remote_connection,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RemoteConnectionReply) Reset()         { *m = RemoteConnectionReply{} }
func (m *RemoteConnectionReply) String() string { return proto.CompactTextString(m) }
func (*RemoteConnectionReply) ProtoMessage()    {}
func (*RemoteConnectionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_internsm_3a67740ace59b57b, []int{3}
}
func (m *RemoteConnectionReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoteConnectionReply.Unmarshal(m, b)
}
func (m *RemoteConnectionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoteConnectionReply.Marshal(b, m, deterministic)
}
func (dst *RemoteConnectionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteConnectionReply.Merge(dst, src)
}
func (m *RemoteConnectionReply) XXX_Size() int {
	return xxx_messageInfo_RemoteConnectionReply.Size(m)
}
func (m *RemoteConnectionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteConnectionReply.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteConnectionReply proto.InternalMessageInfo

func (m *RemoteConnectionReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *RemoteConnectionReply) GetExtendedError() string {
	if m != nil {
		return m.ExtendedError
	}
	return ""
}

func (m *RemoteConnectionReply) GetRemoteConnection() *RemoteConnection {
	if m != nil {
		return m.RemoteConnection
	}
	return nil
}

// RemoteConnectionUpdate - Update on a RemoteConnection
// Should be returned from MonitorRemoteConnection when:
//     1)  RemoteConnectionState of the RemoteConnection changes
//     2)  Periodically to update metrics on RemoteConnection
// Uses:
//     - Updating 'recoverying' peer NSM on peer NSM restart on existing RemoteConnections
//     - Updating peer NSM of unrequested CLOSING of a RemoteConnection
//     - Updating peer NSM of metrics on RemoteConnections - can be used to detect failure modes requiring
//       auto-healing
type RemoteConnectionUpdate struct {
	// remote_connection - fully specified RemoteConnection that is the subject of this update
	RemoteConnection *RemoteConnection `protobuf:"bytes,1,opt,name=remote_connection,json=remoteConnection" json:"remote_connection,omitempty"`
	//  metrics - key value pairs of metrics for the fully RemoteConnection
	Metrics              map[string]string `protobuf:"bytes,2,rep,name=metrics" json:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RemoteConnectionUpdate) Reset()         { *m = RemoteConnectionUpdate{} }
func (m *RemoteConnectionUpdate) String() string { return proto.CompactTextString(m) }
func (*RemoteConnectionUpdate) ProtoMessage()    {}
func (*RemoteConnectionUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_internsm_3a67740ace59b57b, []int{4}
}
func (m *RemoteConnectionUpdate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoteConnectionUpdate.Unmarshal(m, b)
}
func (m *RemoteConnectionUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoteConnectionUpdate.Marshal(b, m, deterministic)
}
func (dst *RemoteConnectionUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteConnectionUpdate.Merge(dst, src)
}
func (m *RemoteConnectionUpdate) XXX_Size() int {
	return xxx_messageInfo_RemoteConnectionUpdate.Size(m)
}
func (m *RemoteConnectionUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteConnectionUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteConnectionUpdate proto.InternalMessageInfo

func (m *RemoteConnectionUpdate) GetRemoteConnection() *RemoteConnection {
	if m != nil {
		return m.RemoteConnection
	}
	return nil
}

func (m *RemoteConnectionUpdate) GetMetrics() map[string]string {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func init() {
	proto.RegisterType((*RemoteConnectionId)(nil), "internsm.RemoteConnectionId")
	proto.RegisterType((*RemoteConnection)(nil), "internsm.RemoteConnection")
	proto.RegisterMapType((map[string]string)(nil), "internsm.RemoteConnection.LabelsEntry")
	proto.RegisterType((*RemoteConnectionRequest)(nil), "internsm.RemoteConnectionRequest")
	proto.RegisterType((*RemoteConnectionReply)(nil), "internsm.RemoteConnectionReply")
	proto.RegisterType((*RemoteConnectionUpdate)(nil), "internsm.RemoteConnectionUpdate")
	proto.RegisterMapType((map[string]string)(nil), "internsm.RemoteConnectionUpdate.MetricsEntry")
	proto.RegisterEnum("internsm.RemoteConnectionState", RemoteConnectionState_name, RemoteConnectionState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// InterNsmClient is the client API for InterNsm service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InterNsmClient interface {
	// RequestRemoteConnection - Service called by one NSM to request a RemoteConnection to a Network Service Endpoint from another NSM
	RequestRemoteConnection(ctx context.Context, in *RemoteConnectionRequest, opts ...grpc.CallOption) (*RemoteConnectionReply, error)
	// DeleteRemoteConnection - Service called by one NSM to to request a RemoteConnection be deleted
	DeleteRemoteConnection(ctx context.Context, in *RemoteConnection, opts ...grpc.CallOption) (*RemoteConnectionReply, error)
	// UpdateRemoteConnection - Service called by one NSM to request update of a RemoteConnection by another NSM.
	// Note: Only intended to Update ConnectionContext
	UpdateRemoteConnection(ctx context.Context, in *RemoteConnection, opts ...grpc.CallOption) (*RemoteConnectionReply, error)
	// MonitorRemoteConnections - Service called by one NSM to request streaming updates on existing RemoteConnections
	//     RemoteConnectionId - interpreted as a 'selector' with empty fields being wildcarded.
	//                          Example: specifying source_nsm_id will cause streaming of updates for all connections matching source nsm_id
	MonitorRemoteConnections(ctx context.Context, in *RemoteConnectionId, opts ...grpc.CallOption) (InterNsm_MonitorRemoteConnectionsClient, error)
}

type interNsmClient struct {
	cc *grpc.ClientConn
}

func NewInterNsmClient(cc *grpc.ClientConn) InterNsmClient {
	return &interNsmClient{cc}
}

func (c *interNsmClient) RequestRemoteConnection(ctx context.Context, in *RemoteConnectionRequest, opts ...grpc.CallOption) (*RemoteConnectionReply, error) {
	out := new(RemoteConnectionReply)
	err := c.cc.Invoke(ctx, "/internsm.InterNsm/RequestRemoteConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interNsmClient) DeleteRemoteConnection(ctx context.Context, in *RemoteConnection, opts ...grpc.CallOption) (*RemoteConnectionReply, error) {
	out := new(RemoteConnectionReply)
	err := c.cc.Invoke(ctx, "/internsm.InterNsm/DeleteRemoteConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interNsmClient) UpdateRemoteConnection(ctx context.Context, in *RemoteConnection, opts ...grpc.CallOption) (*RemoteConnectionReply, error) {
	out := new(RemoteConnectionReply)
	err := c.cc.Invoke(ctx, "/internsm.InterNsm/UpdateRemoteConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interNsmClient) MonitorRemoteConnections(ctx context.Context, in *RemoteConnectionId, opts ...grpc.CallOption) (InterNsm_MonitorRemoteConnectionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_InterNsm_serviceDesc.Streams[0], "/internsm.InterNsm/MonitorRemoteConnections", opts...)
	if err != nil {
		return nil, err
	}
	x := &interNsmMonitorRemoteConnectionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InterNsm_MonitorRemoteConnectionsClient interface {
	Recv() (*RemoteConnectionUpdate, error)
	grpc.ClientStream
}

type interNsmMonitorRemoteConnectionsClient struct {
	grpc.ClientStream
}

func (x *interNsmMonitorRemoteConnectionsClient) Recv() (*RemoteConnectionUpdate, error) {
	m := new(RemoteConnectionUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for InterNsm service

type InterNsmServer interface {
	// RequestRemoteConnection - Service called by one NSM to request a RemoteConnection to a Network Service Endpoint from another NSM
	RequestRemoteConnection(context.Context, *RemoteConnectionRequest) (*RemoteConnectionReply, error)
	// DeleteRemoteConnection - Service called by one NSM to to request a RemoteConnection be deleted
	DeleteRemoteConnection(context.Context, *RemoteConnection) (*RemoteConnectionReply, error)
	// UpdateRemoteConnection - Service called by one NSM to request update of a RemoteConnection by another NSM.
	// Note: Only intended to Update ConnectionContext
	UpdateRemoteConnection(context.Context, *RemoteConnection) (*RemoteConnectionReply, error)
	// MonitorRemoteConnections - Service called by one NSM to request streaming updates on existing RemoteConnections
	//     RemoteConnectionId - interpreted as a 'selector' with empty fields being wildcarded.
	//                          Example: specifying source_nsm_id will cause streaming of updates for all connections matching source nsm_id
	MonitorRemoteConnections(*RemoteConnectionId, InterNsm_MonitorRemoteConnectionsServer) error
}

func RegisterInterNsmServer(s *grpc.Server, srv InterNsmServer) {
	s.RegisterService(&_InterNsm_serviceDesc, srv)
}

func _InterNsm_RequestRemoteConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoteConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterNsmServer).RequestRemoteConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/internsm.InterNsm/RequestRemoteConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterNsmServer).RequestRemoteConnection(ctx, req.(*RemoteConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterNsm_DeleteRemoteConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoteConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterNsmServer).DeleteRemoteConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/internsm.InterNsm/DeleteRemoteConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterNsmServer).DeleteRemoteConnection(ctx, req.(*RemoteConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterNsm_UpdateRemoteConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoteConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterNsmServer).UpdateRemoteConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/internsm.InterNsm/UpdateRemoteConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterNsmServer).UpdateRemoteConnection(ctx, req.(*RemoteConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterNsm_MonitorRemoteConnections_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RemoteConnectionId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InterNsmServer).MonitorRemoteConnections(m, &interNsmMonitorRemoteConnectionsServer{stream})
}

type InterNsm_MonitorRemoteConnectionsServer interface {
	Send(*RemoteConnectionUpdate) error
	grpc.ServerStream
}

type interNsmMonitorRemoteConnectionsServer struct {
	grpc.ServerStream
}

func (x *interNsmMonitorRemoteConnectionsServer) Send(m *RemoteConnectionUpdate) error {
	return x.ServerStream.SendMsg(m)
}

var _InterNsm_serviceDesc = grpc.ServiceDesc{
	ServiceName: "internsm.InterNsm",
	HandlerType: (*InterNsmServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestRemoteConnection",
			Handler:    _InterNsm_RequestRemoteConnection_Handler,
		},
		{
			MethodName: "DeleteRemoteConnection",
			Handler:    _InterNsm_DeleteRemoteConnection_Handler,
		},
		{
			MethodName: "UpdateRemoteConnection",
			Handler:    _InterNsm_UpdateRemoteConnection_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MonitorRemoteConnections",
			Handler:       _InterNsm_MonitorRemoteConnections_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "internsm.proto",
}

func init() { proto.RegisterFile("internsm.proto", fileDescriptor_internsm_3a67740ace59b57b) }

var fileDescriptor_internsm_3a67740ace59b57b = []byte{
	// 704 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xd1, 0x4e, 0xdb, 0x48,
	0x14, 0x5d, 0x27, 0x10, 0xe0, 0x66, 0x81, 0x30, 0xcb, 0x82, 0xc9, 0xee, 0x0a, 0x36, 0x52, 0x2b,
	0x54, 0xd1, 0x04, 0xa5, 0xaa, 0xd4, 0xf2, 0x50, 0xa9, 0x0d, 0x16, 0x45, 0x82, 0xa0, 0x3a, 0xa5,
	0x7d, 0x69, 0x65, 0x19, 0xfb, 0x0a, 0x2c, 0x32, 0x33, 0xae, 0x67, 0x42, 0xe1, 0x73, 0xfa, 0x1d,
	0xfd, 0x8d, 0x7e, 0x43, 0xff, 0x80, 0xf7, 0xca, 0x33, 0x63, 0x70, 0x9c, 0x26, 0x2d, 0x12, 0x4f,
	0xc9, 0xdc, 0x7b, 0xce, 0xf5, 0x3d, 0x67, 0x4e, 0x1c, 0x58, 0x88, 0x98, 0xc4, 0x84, 0x09, 0xda,
	0x8c, 0x13, 0x2e, 0x39, 0x99, 0xcd, 0xce, 0x75, 0xe7, 0x34, 0x92, 0x67, 0x83, 0x93, 0x66, 0xc0,
	0x69, 0xab, 0x1f, 0x9d, 0xfa, 0x92, 0xb7, 0x18, 0xca, 0xcf, 0x3c, 0x39, 0x17, 0x98, 0x5c, 0x44,
	0x01, 0x52, 0x14, 0x67, 0xad, 0xf8, 0xfc, 0xb4, 0xc5, 0x04, 0x6d, 0xf9, 0x71, 0x24, 0x5a, 0x01,
	0xa7, 0x94, 0x33, 0xf3, 0xa1, 0x07, 0x36, 0xbe, 0x59, 0x40, 0x5c, 0xa4, 0x5c, 0x62, 0x87, 0x33,
	0x86, 0x81, 0x8c, 0x38, 0xdb, 0x0f, 0x49, 0x03, 0xe6, 0x05, 0x1f, 0x24, 0x01, 0x7a, 0x4c, 0x50,
	0x2f, 0x0a, 0x6d, 0x6b, 0xc3, 0xda, 0x9c, 0x73, 0xab, 0xba, 0xd8, 0x15, 0x74, 0x3f, 0x24, 0x5b,
	0x40, 0x42, 0x14, 0x32, 0x62, 0x7e, 0x4a, 0xca, 0x80, 0x25, 0x05, 0xac, 0xe5, 0x3a, 0x1a, 0xbd,
	0x0d, 0xcb, 0x66, 0x62, 0x70, 0xf3, 0xa0, 0x14, 0x5f, 0x56, 0x78, 0xa2, 0x7b, 0x43, 0x3b, 0xec,
	0xc0, 0x5a, 0x7e, 0xfe, 0x30, 0x6d, 0x4a, 0xd1, 0x56, 0x73, 0x80, 0x3c, 0xb7, 0x71, 0x5d, 0x86,
	0x5a, 0x51, 0x16, 0xd9, 0x82, 0x92, 0x51, 0x52, 0x6d, 0xff, 0xdb, 0xbc, 0x71, 0x76, 0x54, 0xbe,
	0x5b, 0x8a, 0x42, 0xf2, 0x14, 0xa6, 0x85, 0xf4, 0x25, 0x2a, 0x45, 0x0b, 0xed, 0xf5, 0xf1, 0x84,
	0x5e, 0x0a, 0x73, 0x35, 0x3a, 0xd5, 0x69, 0xee, 0xc1, 0x33, 0x17, 0xe1, 0x31, 0x9f, 0x62, 0xa6,
	0xd3, 0xf4, 0x7a, 0xba, 0xd5, 0xf5, 0x29, 0x92, 0x97, 0xf0, 0x5f, 0x91, 0x81, 0x2c, 0x8c, 0x79,
	0xc4, 0xa4, 0xa6, 0x6a, 0xad, 0xf5, 0x61, 0xaa, 0x63, 0x20, 0x6a, 0xc4, 0x2b, 0xa8, 0x25, 0x6a,
	0x29, 0x8f, 0x62, 0x70, 0xe6, 0xb3, 0x48, 0x50, 0x7b, 0x5a, 0xe9, 0x5c, 0x6d, 0x9a, 0xeb, 0xd6,
	0x4b, 0x1f, 0x66, 0x6d, 0x77, 0x31, 0x19, 0x2e, 0x90, 0xd7, 0x40, 0x72, 0x16, 0x07, 0x9c, 0x49,
	0xbc, 0x94, 0x76, 0x45, 0x4d, 0x59, 0xcb, 0xa6, 0xdc, 0x8a, 0xee, 0x68, 0x80, 0xbb, 0x14, 0x14,
	0x4b, 0xe4, 0x05, 0x54, 0xfa, 0xfe, 0x09, 0xf6, 0x85, 0x3d, 0xb3, 0x51, 0xde, 0xac, 0xb6, 0x1f,
	0x8e, 0xb7, 0xae, 0x79, 0xa0, 0x80, 0x0e, 0x93, 0xc9, 0x95, 0x6b, 0x58, 0xf5, 0xe7, 0x50, 0xcd,
	0x95, 0x49, 0x0d, 0xca, 0xe7, 0x78, 0x65, 0x12, 0x98, 0x7e, 0x25, 0xcb, 0x30, 0x7d, 0xe1, 0xf7,
	0x07, 0x68, 0xc2, 0xa6, 0x0f, 0x3b, 0xa5, 0x67, 0x56, 0xe3, 0xab, 0x05, 0xab, 0xc5, 0x67, 0xb8,
	0xf8, 0x69, 0x80, 0x42, 0x92, 0x3d, 0x58, 0x32, 0x26, 0xdd, 0xae, 0x6c, 0xd2, 0x50, 0x1f, 0xbf,
	0xa1, 0x6b, 0x9c, 0xcd, 0xe5, 0xe8, 0x3d, 0xfc, 0x23, 0x06, 0x71, 0xcc, 0x13, 0x89, 0xa1, 0x57,
	0xf4, 0x5d, 0xd8, 0x53, 0x4a, 0xf4, 0x58, 0xe3, 0xd7, 0x6e, 0xb8, 0x85, 0x8e, 0x68, 0x7c, 0xb1,
	0xe0, 0xef, 0xd1, 0xed, 0xe3, 0xfe, 0x15, 0xb1, 0x61, 0x46, 0x0c, 0x82, 0x00, 0x85, 0x50, 0x1b,
	0xcf, 0xba, 0xd9, 0x91, 0x3c, 0x80, 0x05, 0xbc, 0x94, 0xc8, 0x42, 0x0c, 0x3d, 0x4c, 0x12, 0x9e,
	0x18, 0x53, 0xe6, 0xb3, 0xaa, 0x93, 0x16, 0x7f, 0x2e, 0xbe, 0x7c, 0x77, 0xf1, 0x8d, 0xef, 0x16,
	0xac, 0x14, 0x61, 0xc7, 0x71, 0x98, 0x46, 0xff, 0xde, 0x0c, 0xde, 0x83, 0x19, 0x8a, 0x32, 0x89,
	0x02, 0x61, 0x97, 0x94, 0x99, 0x8f, 0xc7, 0xd3, 0xf5, 0xb3, 0x9b, 0x87, 0x1a, 0xaf, 0x83, 0x94,
	0xb1, 0xeb, 0x3b, 0xf0, 0x67, 0xbe, 0x71, 0x97, 0x28, 0x3d, 0x7a, 0x37, 0x7a, 0x17, 0xea, 0x87,
	0x4e, 0xe6, 0x61, 0xce, 0x75, 0xde, 0x1c, 0x3b, 0xbd, 0xb7, 0xce, 0x6e, 0xed, 0x8f, 0xf4, 0xd8,
	0x39, 0xea, 0x76, 0x9d, 0x4e, 0x7a, 0xb4, 0xc8, 0x5f, 0xb0, 0xd8, 0x39, 0x38, 0xea, 0x39, 0xde,
	0x2d, 0xa6, 0x44, 0x00, 0x2a, 0xaa, 0xb8, 0x5b, 0x2b, 0xb7, 0xaf, 0x4b, 0x30, 0xbb, 0x9f, 0xaa,
	0xe9, 0x0a, 0x4a, 0x3e, 0xa6, 0x71, 0x55, 0xf1, 0x1c, 0x79, 0x5b, 0xfd, 0x3f, 0xc1, 0x32, 0x4d,
	0xa9, 0xaf, 0x4f, 0x82, 0xa4, 0xb1, 0x39, 0x86, 0x95, 0x5d, 0xec, 0xa3, 0xc4, 0x91, 0xe9, 0x13,
	0x2e, 0xe4, 0xb7, 0xc6, 0x6a, 0xdb, 0xef, 0x77, 0xec, 0x07, 0xb0, 0x0f, 0x39, 0x8b, 0x24, 0x4f,
	0x8a, 0x7d, 0x41, 0x26, 0xbe, 0xaf, 0xeb, 0x1b, 0xbf, 0xca, 0xc7, 0xb6, 0x75, 0x52, 0x51, 0x7f,
	0x78, 0x4f, 0x7e, 0x04, 0x00, 0x00, 0xff, 0xff, 0x8b, 0x28, 0xe8, 0x80, 0x53, 0x07, 0x00, 0x00,
}
